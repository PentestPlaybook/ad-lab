import os
import sys
import logging
import base64
import requests
from http.server import HTTPServer, BaseHTTPRequestHandler
from socketserver import ThreadingMixIn
import gssapi
from ldap3 import Server, Connection, ALL, NTLM

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------
KEYTAB_PATH = "FILE:C:\\Users\\daron.AD\\Documents\\web04.keytab"
LISTEN_PORT = 80
FORWARD_HOST = "127.0.0.1"
FORWARD_PORT = 8080
LOG_LEVEL = logging.DEBUG

# LDAP Configuration
LDAP_SERVER = 'ldaps://dc02.ad.set'          # Replace with your AD server address
LDAP_USER = 'AD\\betty'               # Service account with read access to AD
LDAP_PASSWORD = 'Password123'              # Password for the service account
AUTHORIZED_USERS = {
    "AD\\DOES-NOT-EXIST",
    "DOES-NOT-EXIST@AD.SET"
}  # AD usernames in uppercase (DOMAIN\username and username@DOMAIN)
AUTHORIZED_GROUPS = {"ADMINISTRATORS"}       # AD group names in uppercase

# -----------------------------------------------------------------------------
# Logger setup
# -----------------------------------------------------------------------------
logger = logging.getLogger(__name__)
logging.basicConfig(
    level=LOG_LEVEL,
    format="%(asctime)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)

# -----------------------------------------------------------------------------
# Set the keytab environment variable so the GSSAPI library uses it.
# -----------------------------------------------------------------------------
os.environ["KRB5_KTNAME"] = KEYTAB_PATH

# -----------------------------------------------------------------------------
# LDAP Helper Functions
# -----------------------------------------------------------------------------
def get_user_groups(principal_name):
    """
    Query Active Directory to get the groups of the given principal.
    Returns a set of group names in uppercase.
    """
    try:
        # Initialize LDAP server and connection
        server = Server(LDAP_SERVER, get_info=ALL, use_ssl=True)
        conn = Connection(server, user=LDAP_USER, password=LDAP_PASSWORD, authentication=NTLM, auto_bind=True)

        # Normalize and split principal name into domain and username
        if '\\' in principal_name:
            domain, username = principal_name.split('\\', 1)
        elif '@' in principal_name:
            username, domain_full = principal_name.split('@', 1)
            # Optionally, extract short domain name if needed
            domain = domain_full.split('.')[0].upper()
        else:
            logger.error(f"Unrecognized principal name format: {principal_name}")
            return set()

        username = username.strip()

        # Search for the user
        search_base = 'DC=ad,DC=set'  # Adjust based on your AD structure
        search_filter = f'(&(objectClass=user)(sAMAccountName={username}))'
        conn.search(search_base, search_filter, attributes=['memberOf'])

        if not conn.entries:
            logger.error(f"User {username} not found in AD.")
            return set()

        user_entry = conn.entries[0]
        member_of = user_entry.memberOf.values if 'memberOf' in user_entry else []

        # Extract group names from distinguished names and normalize to uppercase
        groups = set()
        for dn in member_of:
            # Assuming the group name is the CN
            parts = dn.split(',')
            for part in parts:
                if part.startswith('CN='):
                    group_name = part[3:].strip().upper()  # Convert to uppercase
                    groups.add(group_name)
                    break  # Only the CN part is needed

        conn.unbind()
        return groups

    except Exception as e:
        logger.exception("Failed to retrieve user groups from AD.")
        return set()

# -----------------------------------------------------------------------------
# Kerberos/Negotiate Handler
# -----------------------------------------------------------------------------
class KerberosNegotiateHandler(BaseHTTPRequestHandler):
    """
    An HTTP handler that performs SPNEGO/Kerberos authentication, enforces
    authorization based on individual user accounts or group membership, and proxies
    valid requests to 127.0.0.1:8080. Returns 404 if file not found upstream,
    403 if unauthorized, or if the path is not /login.asp.
    """
    protocol_version = "HTTP/1.1"  # Ensure responses use HTTP/1.1

    def do_AUTHHEAD(self, negotiate_token=None):
        """
        Send the 401 header with optional Negotiate token.
        """
        self.send_response(401, "Unauthorized")
        if negotiate_token:
            self.send_header("WWW-Authenticate", "Negotiate " + negotiate_token)
        else:
            self.send_header("WWW-Authenticate", "Negotiate")
        self.send_header("Content-Length", "0")  # No body
        self.send_header("Connection", "close")  # Close the connection
        self.end_headers()

    def negotiate_step(self, in_token):
        """
        Perform one step in SPNEGO negotiation with GSSAPI.
        Returns (out_token, completed_bool, context).
        """
        try:
            # Acquire credentials from the keytab for the principal in the keytab
            service_name = gssapi.Name(
                "HTTP@{}".format(self.server.server_name),
                gssapi.NameType.hostbased_service
            )
            creds = gssapi.Credentials(name=service_name, usage='accept')
            ctx = gssapi.SecurityContext(creds=creds, usage='accept')

            out_token = ctx.step(in_token)
            return (out_token, ctx.complete, ctx)

        except Exception as e:
            logger.exception("GSSAPI negotiation step failed")
            return (None, False, None)

    def authenticate_kerberos(self):
        """
        Common Kerberos/Negotiate authentication logic. 
        Returns the authenticated principal name if successful, otherwise None.
        Also sends final or intermediate tokens if negotiation is ongoing.
        """
        # 1. Check for 'Authorization: Negotiate ...' header
        auth_header = self.headers.get('Authorization', '')
        if not auth_header.startswith('Negotiate'):
            # No token provided or not Negotiate -> challenge
            logger.debug("No or invalid Auth header; requesting Negotiate")
            self.do_AUTHHEAD()
            return None

        # 2. Extract the SPNEGO token from the header
        try:
            token_base64 = auth_header.split()[1]
            in_token = base64.b64decode(token_base64)
            logger.debug(f"Incoming token (base64 decoded): {in_token}")
        except Exception:
            logger.debug("Failed to parse SPNEGO token from header.")
            self.do_AUTHHEAD()
            return None

        # 3. Perform the Kerberos negotiation step
        out_token, completed, ctx = self.negotiate_step(in_token)
        if out_token:
            if not completed:
                # Not done yet; send the partially completed token back
                logger.debug("GSSAPI context not complete, sending 401 with SPNEGO token.")
                self.do_AUTHHEAD(base64.b64encode(out_token).decode('ascii'))
                return None
            else:
                # Context is complete; proceed without sending headers
                logger.debug("GSSAPI context established; proceeding to handle request.")
        else:
            # out_token is None or negotiation failed
            logger.debug("No output token or negotiation failed.")
            self.do_AUTHHEAD()
            return None

        # 4. Extract the authenticated user's principal name
        try:
            user_name = str(ctx.initiator_name).upper()  # Normalize to uppercase
            logger.debug(f"Authenticated user: {user_name}")
            return user_name
        except Exception as e:
            logger.exception("Failed to extract user identity from GSSAPI context.")
            return None

    def authorize_user(self, principal_name):
        """
        Check if the authenticated user is authorized to access the resource based on
        individual user accounts or group membership.
        Returns True if authorized, False otherwise.
        """
        # Retrieve user groups from AD
        groups = get_user_groups(principal_name)
        logger.debug(f"User {principal_name} is member of groups: {groups}")
        logger.debug(f"Normalized Authorized Groups: {AUTHORIZED_GROUPS}")

        # Normalize principal name for comparison (already uppercase)
        principal_normalized = principal_name  # Already uppercase

        # Check if user is in authorized users
        if principal_normalized in AUTHORIZED_USERS:
            logger.debug(f"User {principal_name} is explicitly authorized.")
            return True

        # Check if user is in any authorized group
        if AUTHORIZED_GROUPS.intersection(groups):
            logger.debug(f"User {principal_name} is authorized via group membership.")
            return True

        logger.debug(f"User {principal_name} is not authorized.")
        return False

    def do_GET(self):
        """
        Handles HTTP GET requests with Kerberos Negotiate auth and proxies them
        if the user is authenticated and authorized. If the resource doesn't exist on upstream,
        return 404.
        """
        # 1. Kerberos authenticate
        principal = self.authenticate_kerberos()
        if not principal:
            return

        # 2. Authorization check
        if not self.authorize_user(principal):
            logger.debug(f"Authorization failed for user: {principal}")
            self.send_error(403, "Forbidden: You don't have permission to access this resource.")
            return

        # 3. If authorized, proceed
        requested_path = self.path
        logger.debug(f"Authorized GET request for path: {requested_path}")

        # 4. Check path
        #    For demonstration, we only allow /login.asp
        if requested_path.lower() != "/login.asp":
            logger.debug(f"Requested path {requested_path} not found. Returning 404.")
            self.send_error(404, "File does not exist")
            return

        # 5. Proxy request to upstream server
        upstream_url = f"http://{FORWARD_HOST}:{FORWARD_PORT}{requested_path}"
        logger.debug(f"Proxying GET to {upstream_url}")

        try:
            resp = requests.get(upstream_url)
            if resp.status_code == 404:
                # If upstream returns 404, forward that back
                logger.debug("Upstream returned 404, returning 404 to client.")
                self.send_error(404, "File does not exist")
                return

            # Send the upstream status
            self.send_response(resp.status_code)

            # Forward relevant headers
            # Only forward essential headers to avoid conflicts
            for key, value in resp.headers.items():
                if key.lower() in ["content-type", "location", "set-cookie"]:
                    self.send_header(key, value)

            # Manually set Content-Length
            self.send_header("Content-Length", str(len(resp.content)))

            # Set Connection to close to prevent lingering connections
            self.send_header("Connection", "close")

            self.end_headers()

            # Send the response content
            self.wfile.write(resp.content)
            self.wfile.flush()  # Ensure all data is sent

        except Exception as exc:
            logger.exception("Error proxying GET request.")
            self.send_error(502, f"Bad Gateway: {exc}")

    def do_POST(self):
        """
        Handles HTTP POST requests with Kerberos Negotiate auth and proxies them
        if the user is authenticated and authorized. If the resource doesn't exist on upstream,
        return 404.
        """
        # 1. Kerberos authenticate
        principal = self.authenticate_kerberos()
        if not principal:
            return

        # 2. Authorization check
        if not self.authorize_user(principal):
            logger.debug(f"Authorization failed for user: {principal}")
            self.send_error(403, "Forbidden: You don't have permission to access this resource.")
            return

        # 3. If authorized, proceed
        requested_path = self.path
        logger.debug(f"Authorized POST request for path: {requested_path}")

        # 4. Check path (same check as in do_GET)
        if requested_path.lower() != "/login.asp":
            logger.debug(f"Requested path {requested_path} not found. Returning 404.")
            self.send_error(404, "File does not exist")
            return

        # 5. Read the POST data from the client
        content_length = int(self.headers.get('Content-Length', 0))
        post_data = self.rfile.read(content_length)

        # 6. Proxy the POST to upstream server
        upstream_url = f"http://{FORWARD_HOST}:{FORWARD_PORT}{requested_path}"
        logger.debug(f"Proxying POST to {upstream_url}")
        logger.debug(f"POST data: {post_data}")

        # Forward relevant headers
        # (Filter out certain hop-by-hop headers like Connection, Transfer-Encoding, etc.)
        forward_headers = {}
        for h in self.headers:
            if h.lower() not in ["host", "content-length", "connection", "transfer-encoding"]:
                forward_headers[h] = self.headers[h]
        # Make sure we keep the same Content-Type if present
        if 'content-type' not in forward_headers:
            forward_headers['Content-Type'] = self.headers.get('Content-Type', 'application/octet-stream')

        try:
            resp = requests.post(
                upstream_url,
                data=post_data,
                headers=forward_headers,
                allow_redirects=False
            )

            # Pass along the upstream status
            self.send_response(resp.status_code)

            # Pass along the upstream headers
            for key, value in resp.headers.items():
                if key.lower() in ["content-type", "location", "set-cookie"]:
                    self.send_header(key, value)

            # Manually set Content-Length
            self.send_header("Content-Length", str(len(resp.content)))

            # Set Connection to close to prevent lingering connections
            self.send_header("Connection", "close")

            self.end_headers()

            # Pass along the upstream body
            self.wfile.write(resp.content)
            self.wfile.flush()  # Ensure all data is sent

        except Exception as exc:
            logger.exception("Error proxying POST request.")
            self.send_error(502, f"Bad Gateway: {exc}")

# -----------------------------------------------------------------------------
# Threading HTTP Server
# -----------------------------------------------------------------------------
class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
    """Handle requests in a separate thread."""

# -----------------------------------------------------------------------------
# Main entry point
# -----------------------------------------------------------------------------
def main():
    # Display config
    logger.info(f"Keytab: {KEYTAB_PATH}")
    logger.info(f"Listening on port {LISTEN_PORT}. Forwarding /login.asp to {FORWARD_HOST}:{FORWARD_PORT}")

    server_address = ('0.0.0.0', LISTEN_PORT)
    httpd = ThreadedHTTPServer(server_address, KerberosNegotiateHandler)

    # Ensure the server name matches your keytab principal: HTTP/web04.ad.set
    httpd.server_name = 'web04.ad.set'

    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        logger.info("Server stopped by user.")
    finally:
        httpd.server_close()

if __name__ == "__main__":
    main()
