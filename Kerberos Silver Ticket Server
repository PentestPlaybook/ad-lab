#!/usr/bin/env python3
import os
import sys
import logging
import base64
import requests
from http.server import HTTPServer, BaseHTTPRequestHandler
from socketserver import ThreadingMixIn

import gssapi

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------
KEYTAB_PATH = "FILE:C:\\Users\\daron.AD\\Documents\\web04.keytab"  # No placeholders
LISTEN_PORT = 80
FORWARD_HOST = "127.0.0.1"
FORWARD_PORT = 8080
LOG_LEVEL = logging.DEBUG

# -----------------------------------------------------------------------------
# Logger setup
# -----------------------------------------------------------------------------
logger = logging.getLogger(__name__)
logging.basicConfig(
    level=LOG_LEVEL,
    format="%(asctime)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)

# -----------------------------------------------------------------------------
# Set the keytab environment variable so the GSSAPI library uses it.
# -----------------------------------------------------------------------------
os.environ["KRB5_KTNAME"] = KEYTAB_PATH

# -----------------------------------------------------------------------------
# Kerberos/Negotiate Handler
# -----------------------------------------------------------------------------
class KerberosNegotiateHandler(BaseHTTPRequestHandler):
    """
    An HTTP handler that performs SPNEGO/Kerberos authentication, then
    proxies valid requests to 127.0.0.1:8080. Returns 404 if file not found
    upstream, or if the path is anything besides /login.asp (for example).
    """

    def do_AUTHHEAD(self, negotiate_token=None):
        """
        Send the 401 header with optional Negotiate token.
        """
        self.send_response(401, "Unauthorized")
        if negotiate_token:
            self.send_header("WWW-Authenticate", "Negotiate " + negotiate_token)
        else:
            self.send_header("WWW-Authenticate", "Negotiate")
        self.end_headers()

    def negotiate_step(self, in_token):
        """
        Perform one step in SPNEGO negotiation with GSSAPI.
        Returns (out_token, completed_bool).
        """
        try:
            # Acquire credentials from the keytab for the principal in the keytab
            service_name = gssapi.Name("HTTP@{}".format(self.server.server_name),
                                       gssapi.NameType.hostbased_service)
            creds = gssapi.Credentials(name=service_name, usage='accept')

            ctx = gssapi.SecurityContext(creds=creds, usage='accept')
            out_token = ctx.step(in_token)

            # If ctx is established, then we are done
            return (out_token, ctx.complete)

        except Exception as e:
            logger.exception("GSSAPI negotiation step failed")
            return (None, False)

    def do_GET(self):
        """
        Handles HTTP GET requests with Kerberos Negotiate auth and proxies them
        if the user is authenticated. If the resource doesn't exist on upstream,
        return 404.
        """
        # 1. Check for 'Authorization: Negotiate ...' header
        auth_header = self.headers.get('Authorization', '')
        if not auth_header.startswith('Negotiate'):
            # No token provided or not Negotiate -> challenge
            logger.debug("No or invalid Auth header; requesting Negotiate")
            self.do_AUTHHEAD()
            return

        # 2. Extract the SPNEGO token from the header
        try:
            token_base64 = auth_header.split()[1]
            in_token = base64.b64decode(token_base64)
            logger.debug(f"Incoming token (base64 decoded): {in_token}")
        except Exception as e:
            logger.debug("Failed to parse SPNEGO token from header.")
            self.do_AUTHHEAD()
            return

        # 3. Perform the Kerberos negotiation step
        out_token, completed = self.negotiate_step(in_token)

        if out_token:
            # We have an output token to send back
            # If the context is not complete, we still need more handshake
            if not completed:
                logger.debug("GSSAPI context not complete, sending 401 with SPNEGO token.")
                self.do_AUTHHEAD(base64.b64encode(out_token).decode('ascii'))
                return
            else:
                # Context is complete; send final token to client (if any)
                logger.debug("GSSAPI context established; final token sent.")
                self.send_response(200, "OK")
                self.send_header("WWW-Authenticate", "Negotiate " + base64.b64encode(out_token).decode('ascii'))
                self.end_headers()
        else:
            # If out_token is None or negotiation failed
            logger.debug("No output token or negotiation failed.")
            self.do_AUTHHEAD()
            return

        # 4. If we made it here, the client is authenticated. Now check path.
        requested_path = self.path
        logger.debug(f"Authenticated request for path: {requested_path}")

        # ---------------------------------------------------------------------
        # Customize the resource check logic:
        #
        # If you want to serve only /login.asp from your upstream, you can do:
        #     if requested_path != '/login.asp':
        #         self.send_error(404, "File does not exist")
        #         return
        #
        # Otherwise, adapt to your needs. The snippet below only proxies
        # /login.asp or returns 404 for everything else.
        # ---------------------------------------------------------------------
        if requested_path.lower() != "/login.asp":
            logger.debug(f"Requested path {requested_path} not found. Returning 404.")
            self.send_error(404, "File does not exist")
            return

        # 5. Proxy the request to the upstream server (IIS on 127.0.0.1:8080)
        upstream_url = f"http://{FORWARD_HOST}:{FORWARD_PORT}{requested_path}"
        logger.debug(f"Proxying GET to {upstream_url}")

        try:
            resp = requests.get(upstream_url)
            # If the file doesn't exist upstream, we return 404 to the client
            if resp.status_code == 404:
                logger.debug("Upstream returned 404, returning 404 to client.")
                self.send_error(404, "File does not exist")
                return

            # Otherwise, pass along the status and content
            self.send_response(resp.status_code)
            for key, value in resp.headers.items():
                # Filter out headers that Python's http server will manage on its own.
                if key.lower() not in ["transfer-encoding", "content-encoding", "content-length", "connection"]:
                    self.send_header(key, value)
            self.end_headers()
            self.wfile.write(resp.content)
        except Exception as exc:
            logger.exception("Error proxying request to upstream.")
            self.send_error(502, f"Bad Gateway: {exc}")

    def do_POST(self):
        """
        If you need POST support, replicate do_GET logic with appropriate handling.
        For now, weâ€™ll return 405 (Method Not Allowed) if not desired.
        """
        logger.debug("Received POST request; returning 405 for now.")
        self.send_error(405, "Method Not Allowed")

# -----------------------------------------------------------------------------
# Threading HTTP Server
# -----------------------------------------------------------------------------
class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
    """Handle requests in a separate thread."""

# -----------------------------------------------------------------------------
# Main entry point
# -----------------------------------------------------------------------------
def main():
    # Display config
    logger.info(f"Keytab: {KEYTAB_PATH}")
    logger.info(f"Listening on port {LISTEN_PORT}. Forwarding /login.asp to {FORWARD_HOST}:{FORWARD_PORT}")

    server_address = ('0.0.0.0', LISTEN_PORT)
    httpd = ThreadedHTTPServer(server_address, KerberosNegotiateHandler)

    # If you want to specify a custom 'server_name', you can do so here:
    # e.g. httpd.server_name = 'web04.ad.set'
    # but for correctness, ensure it matches your keytab principal name.
    httpd.server_name = 'web04.ad.set'

    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        logger.info("Server stopped by user.")
    finally:
        httpd.server_close()

if __name__ == "__main__":
    main()
