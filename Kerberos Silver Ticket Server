import http.server
import socketserver
import base64
import os
import logging
from http.server import BaseHTTPRequestHandler, HTTPServer

import gssapi
import requests

# Configure logging
logging.basicConfig(level=logging.DEBUG, format="%(asctime)s - %(levelname)s - %(message)s")

class KerberosHTTPRequestHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        """
        Handle GET requests:
        1. Attempt Kerberos authentication.
        2. If successful, reverse-proxy the request to IIS on port 8080.
        3. Return the IIS response to the client.
        """

        try:
            auth_header = self.headers.get("Authorization")
            logging.debug(f"Authorization header received: {auth_header}")

            # If there's no Negotiate header, ask the client to authenticate
            if not auth_header or not auth_header.startswith("Negotiate "):
                self.send_response(401)
                self.send_header("WWW-Authenticate", "Negotiate")
                self.end_headers()
                return

            # Extract the Base64 token
            token_b64 = auth_header.split(" ")[1]
            logging.debug(f"Received Kerberos Token (Base64): {token_b64}")

            # Decode the token from Base64
            token = base64.b64decode(token_b64)
            logging.debug(f"Decoded Kerberos Token (raw bytes): {token}")

            # Acquire credentials for the specific service principal: HTTP/web04.ad.set
            server_name = gssapi.Name(
                "HTTP@web04.ad.set",
                name_type=gssapi.NameType.hostbased_service
            )
            server_creds = gssapi.Credentials(name=server_name, usage='accept')

            # Create the security context in 'accept' mode
            context = gssapi.SecurityContext(creds=server_creds, usage='accept')

            # Attempt to process the incoming token
            returned_token = context.step(token)

            # Verify if the context is fully established
            if not context.complete:
                logging.error("GSSAPI context is not complete. Authentication failed.")
                self.send_response(401)
                self.end_headers()
                return

            logging.info("Kerberos authentication successful.")

            # If Kerberos auth is successful, forward the request to IIS on port 8080
            self.forward_to_iis()

        except gssapi.exceptions.GSSError as e:
            logging.error(f"GSSAPI Error: {e}")
            self.send_response(500)
            self.end_headers()
            self.wfile.write(b"Internal Server Error: Kerberos authentication failed.")

    def forward_to_iis(self):
        """
        Reverse-proxy the current GET request to a backend server (IIS on port 8080),
        then send the backend's response back to the client.
        """

        # Construct the URL to which we are proxying
        # (Here, we assume IIS is running on the same host, on port 8080)
        backend_url = f"http://127.0.0.1:8080{self.path}"

        # Copy headers from the client request, but remove Host (so requests can re-set it).
        # You can remove or modify other headers here as needed.
        headers = dict(self.headers)
        headers.pop('Host', None)

        try:
            # Forward the GET request to the backend (IIS) using 'requests'
            response = requests.get(backend_url, headers=headers, allow_redirects=False)

            # Send status code from the IIS response
            self.send_response(response.status_code)

            # Forward headers from the IIS response
            for key, value in response.headers.items():
                # Important: Some headers like 'Transfer-Encoding' might cause issues;
                # adjust logic as needed.
                self.send_header(key, value)
            self.end_headers()

            # Write the body (ASP-rendered HTML, etc.) from IIS back to the client
            self.wfile.write(response.content)

        except requests.RequestException as e:
            # If there's any error in connecting or forwarding, send a 502 Bad Gateway.
            logging.error(f"Error forwarding to IIS: {e}")
            self.send_response(502)
            self.end_headers()
            self.wfile.write(b"Bad Gateway")


def run_server(port=80):
    server_address = ('', port)
    httpd = HTTPServer(server_address, KerberosHTTPRequestHandler)
    logging.info(f"Serving on port {port}...")
    httpd.serve_forever()

if __name__ == "__main__":
    # Force MIT Kerberos for Windows to load the specified keytab
    keytab_path = r"FILE:C:\Users\daron.AD\Documents\web04.keytab"
    os.environ["KRB5_KTNAME"] = keytab_path
    logging.info(f"Using keytab file: {keytab_path}")

    try:
        run_server()
    except KeyboardInterrupt:
        logging.info("Server stopped by user.")
    except Exception as e:
        logging.error(f"Unexpected error: {e}")
