#!/usr/bin/env python3
import os
import sys
import logging
import base64
import requests
from http.server import HTTPServer, BaseHTTPRequestHandler
from socketserver import ThreadingMixIn

import gssapi

# -----------------------------------------------------------------------------
# Configuration
# -----------------------------------------------------------------------------
KEYTAB_PATH = "FILE:C:\\Users\\daron.AD\\Documents\\web04.keytab"  # No placeholders
LISTEN_PORT = 80
FORWARD_HOST = "127.0.0.1"
FORWARD_PORT = 8080
LOG_LEVEL = logging.DEBUG

# -----------------------------------------------------------------------------
# Logger setup
# -----------------------------------------------------------------------------
logger = logging.getLogger(__name__)
logging.basicConfig(
    level=LOG_LEVEL,
    format="%(asctime)s - %(levelname)s - %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S",
)

# -----------------------------------------------------------------------------
# Set the keytab environment variable so the GSSAPI library uses it.
# -----------------------------------------------------------------------------
os.environ["KRB5_KTNAME"] = KEYTAB_PATH

# -----------------------------------------------------------------------------
# Kerberos/Negotiate Handler
# -----------------------------------------------------------------------------
class KerberosNegotiateHandler(BaseHTTPRequestHandler):
    """
    An HTTP handler that performs SPNEGO/Kerberos authentication, then
    proxies valid requests to 127.0.0.1:8080. Returns 404 if file not found
    upstream, or if the path is not /login.asp (adjust as needed).
    """

    def do_AUTHHEAD(self, negotiate_token=None):
        """
        Send the 401 header with optional Negotiate token.
        """
        self.send_response(401, "Unauthorized")
        if negotiate_token:
            self.send_header("WWW-Authenticate", "Negotiate " + negotiate_token)
        else:
            self.send_header("WWW-Authenticate", "Negotiate")
        self.end_headers()

    def negotiate_step(self, in_token):
        """
        Perform one step in SPNEGO negotiation with GSSAPI.
        Returns (out_token, completed_bool).
        """
        try:
            # Acquire credentials from the keytab for the principal in the keytab
            service_name = gssapi.Name(
                "HTTP@{}".format(self.server.server_name),
                gssapi.NameType.hostbased_service
            )
            creds = gssapi.Credentials(name=service_name, usage='accept')
            ctx = gssapi.SecurityContext(creds=creds, usage='accept')

            out_token = ctx.step(in_token)
            return (out_token, ctx.complete)

        except Exception as e:
            logger.exception("GSSAPI negotiation step failed")
            return (None, False)

    def authenticate_kerberos(self):
        """
        Common Kerberos/Negotiate authentication logic. 
        Returns True if fully authenticated, otherwise False (and a 401 is sent).
        Also sends final or intermediate tokens if negotiation is ongoing.
        """
        # 1. Check for 'Authorization: Negotiate ...' header
        auth_header = self.headers.get('Authorization', '')
        if not auth_header.startswith('Negotiate'):
            # No token provided or not Negotiate -> challenge
            logger.debug("No or invalid Auth header; requesting Negotiate")
            self.do_AUTHHEAD()
            return False

        # 2. Extract the SPNEGO token from the header
        try:
            token_base64 = auth_header.split()[1]
            in_token = base64.b64decode(token_base64)
            logger.debug(f"Incoming token (base64 decoded): {in_token}")
        except Exception:
            logger.debug("Failed to parse SPNEGO token from header.")
            self.do_AUTHHEAD()
            return False

        # 3. Perform the Kerberos negotiation step
        out_token, completed = self.negotiate_step(in_token)
        if out_token:
            if not completed:
                # Not done yet; send the partially completed token back
                logger.debug("GSSAPI context not complete, sending 401 with SPNEGO token.")
                self.do_AUTHHEAD(base64.b64encode(out_token).decode('ascii'))
                return False
            else:
                # Context is complete; send final token (if any) and 200
                logger.debug("GSSAPI context established; final token sent.")
                self.send_response(200, "OK")
                self.send_header("WWW-Authenticate", "Negotiate " + base64.b64encode(out_token).decode('ascii'))
                self.end_headers()
        else:
            # out_token is None or negotiation failed
            logger.debug("No output token or negotiation failed.")
            self.do_AUTHHEAD()
            return False

        return True

    def do_GET(self):
        """
        Handles HTTP GET requests with Kerberos Negotiate auth and proxies them
        if the user is authenticated. If the resource doesn't exist on upstream,
        return 404.
        """
        # 1. Kerberos authenticate
        if not self.authenticate_kerberos():
            return

        # 2. If we get here, user is authenticated
        requested_path = self.path
        logger.debug(f"Authenticated GET request for path: {requested_path}")

        # 3. Check path
        #    For demonstration, we only allow /login.asp
        if requested_path.lower() != "/login.asp":
            logger.debug(f"Requested path {requested_path} not found. Returning 404.")
            self.send_error(404, "File does not exist")
            return

        # 4. Proxy request to upstream server
        upstream_url = f"http://{FORWARD_HOST}:{FORWARD_PORT}{requested_path}"
        logger.debug(f"Proxying GET to {upstream_url}")

        try:
            resp = requests.get(upstream_url)
            if resp.status_code == 404:
                # If upstream returns 404, forward that back
                logger.debug("Upstream returned 404, returning 404 to client.")
                self.send_error(404, "File does not exist")
                return

            self.send_response(resp.status_code)
            for key, value in resp.headers.items():
                if key.lower() not in ["transfer-encoding", "content-encoding", "content-length", "connection"]:
                    self.send_header(key, value)
            self.end_headers()
            self.wfile.write(resp.content)

        except Exception as exc:
            logger.exception("Error proxying GET request.")
            self.send_error(502, f"Bad Gateway: {exc}")

    def do_POST(self):
        """
        Handles HTTP POST requests similarly to do_GET, except we also read
        the request body and proxy it to the upstream server.
        """
        # 1. Kerberos authenticate
        if not self.authenticate_kerberos():
            return

        requested_path = self.path
        logger.debug(f"Authenticated POST request for path: {requested_path}")

        # 2. Check path (same check as in do_GET)
        if requested_path.lower() != "/login.asp":
            logger.debug(f"Requested path {requested_path} not found. Returning 404.")
            self.send_error(404, "File does not exist")
            return

        # 3. Read the POST data from the client
        content_length = int(self.headers.get('Content-Length', 0))
        post_data = self.rfile.read(content_length)

        # 4. Proxy the POST to upstream
        upstream_url = f"http://{FORWARD_HOST}:{FORWARD_PORT}{requested_path}"
        logger.debug(f"Proxying POST to {upstream_url}")
        logger.debug(f"POST data: {post_data}")

        # Forward relevant headers
        # (Filter out certain hop-by-hop headers like Connection, Transfer-Encoding, etc.)
        forward_headers = {}
        for h in self.headers:
            if h.lower() not in ["host", "content-length", "connection", "transfer-encoding"]:
                forward_headers[h] = self.headers[h]
        # Make sure we keep the same Content-Type if present
        if 'content-type' not in forward_headers:
            forward_headers['Content-Type'] = self.headers.get('Content-Type', 'application/octet-stream')

        try:
            resp = requests.post(
                upstream_url,
                data=post_data,
                headers=forward_headers,
                allow_redirects=False
            )

            # Pass along the upstream status
            self.send_response(resp.status_code)

            # Pass along the upstream headers
            for key, value in resp.headers.items():
                if key.lower() not in ["transfer-encoding", "content-encoding", "content-length", "connection"]:
                    self.send_header(key, value)
            self.end_headers()

            # Pass along the upstream body
            self.wfile.write(resp.content)

        except Exception as exc:
            logger.exception("Error proxying POST request.")
            self.send_error(502, f"Bad Gateway: {exc}")


# -----------------------------------------------------------------------------
# Threading HTTP Server
# -----------------------------------------------------------------------------
class ThreadedHTTPServer(ThreadingMixIn, HTTPServer):
    """Handle requests in a separate thread."""

# -----------------------------------------------------------------------------
# Main entry point
# -----------------------------------------------------------------------------
def main():
    # Display config
    logger.info(f"Keytab: {KEYTAB_PATH}")
    logger.info(f"Listening on port {LISTEN_PORT}. Forwarding /login.asp to {FORWARD_HOST}:{FORWARD_PORT}")

    server_address = ('0.0.0.0', LISTEN_PORT)
    httpd = ThreadedHTTPServer(server_address, KerberosNegotiateHandler)

    # Ensure the server name here matches your keytab principal: HTTP/web04.ad.set
    httpd.server_name = 'web04.ad.set'

    try:
        httpd.serve_forever()
    except KeyboardInterrupt:
        logger.info("Server stopped by user.")
    finally:
        httpd.server_close()

if __name__ == "__main__":
    main()
